// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Naki3D.Common.Json;
//
//    var packageDescriptor = PackageDescriptor.FromJson(jsonString);

namespace Naki3D.Common.Json
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class PackageDescriptor
    {
        [JsonProperty("$schema")]
        public string Schema { get; set; }

        [JsonProperty("inputs", NullValueHandling = NullValueHandling.Ignore)]
        public List<Action> Inputs { get; set; }

        [JsonProperty("metadata")]
        public Metadata Metadata { get; set; }

        [JsonProperty("package")]
        public Package Package { get; set; }

        [JsonProperty("parameters", NullValueHandling = NullValueHandling.Ignore)]
        public Parameters Parameters { get; set; }

        [JsonProperty("sync", NullValueHandling = NullValueHandling.Ignore)]
        public Sync Sync { get; set; }

        [JsonProperty("version")]
        public string Version { get; set; }
    }

    public partial class Action
    {
        [JsonProperty("effect")]
        public string Effect { get; set; }

        [JsonProperty("mapping")]
        public Mapping Mapping { get; set; }

        [JsonProperty("type")]
        public TypeEnum Type { get; set; }
    }

    public partial class Mapping
    {
        [JsonProperty("source")]
        public string Source { get; set; }

        [JsonProperty("transform", NullValueHandling = NullValueHandling.Ignore)]
        public Transform Transform { get; set; }
    }

    public partial class Transform
    {
        [JsonProperty("from", NullValueHandling = NullValueHandling.Ignore)]
        public string From { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public string Value { get; set; }

        [JsonProperty("comparisonType", NullValueHandling = NullValueHandling.Ignore)]
        public string ComparisonType { get; set; }

        [JsonProperty("comparisonValue", NullValueHandling = NullValueHandling.Ignore)]
        public ComparisonValue? ComparisonValue { get; set; }

        [JsonProperty("inMax", NullValueHandling = NullValueHandling.Ignore)]
        public InM? InMax { get; set; }

        [JsonProperty("inMin", NullValueHandling = NullValueHandling.Ignore)]
        public InM? InMin { get; set; }

        [JsonProperty("outMax", NullValueHandling = NullValueHandling.Ignore)]
        public OutM? OutMax { get; set; }

        [JsonProperty("outMin", NullValueHandling = NullValueHandling.Ignore)]
        public OutM? OutMin { get; set; }

        [JsonProperty("rangeMaxValue", NullValueHandling = NullValueHandling.Ignore)]
        public double? RangeMaxValue { get; set; }

        [JsonProperty("roundingMethod", NullValueHandling = NullValueHandling.Ignore)]
        public RoundingMethod? RoundingMethod { get; set; }

        [JsonProperty("passValue", NullValueHandling = NullValueHandling.Ignore)]
        public string PassValue { get; set; }
    }

    public partial class Metadata
    {
        [JsonProperty("author")]
        public string Author { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("exposition")]
        public string Exposition { get; set; }

        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("other", NullValueHandling = NullValueHandling.Ignore)]
        public List<Other> Other { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }
    }

    public partial class Other
    {
        [JsonProperty("key")]
        public string Key { get; set; }

        [JsonProperty("value")]
        public string Value { get; set; }
    }

    public partial class Package
    {
        [JsonProperty("checksum")]
        public string Checksum { get; set; }

        [JsonProperty("url")]
        public Uri Url { get; set; }
    }

    public partial class Parameters
    {
        [JsonProperty("displayType", NullValueHandling = NullValueHandling.Ignore)]
        public string DisplayType { get; set; }

        [JsonProperty("settings", NullValueHandling = NullValueHandling.Ignore)]
        public Settings Settings { get; set; }
    }

    public partial class Settings
    {
        [JsonProperty("backgroundColor", NullValueHandling = NullValueHandling.Ignore)]
        public string BackgroundColor { get; set; }

        [JsonProperty("layout", NullValueHandling = NullValueHandling.Ignore)]
        public Layout Layout { get; set; }

        [JsonProperty("layoutType", NullValueHandling = NullValueHandling.Ignore)]
        public LayoutType? LayoutType { get; set; }

        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        public Vector2 Padding { get; set; }

        [JsonProperty("scrollDelay", NullValueHandling = NullValueHandling.Ignore)]
        public double? ScrollDelay { get; set; }

        [JsonProperty("slideAnimationLength", NullValueHandling = NullValueHandling.Ignore)]
        public double? SlideAnimationLength { get; set; }

        [JsonProperty("cameraAnimation", NullValueHandling = NullValueHandling.Ignore)]
        public CameraAnimation CameraAnimation { get; set; }

        [JsonProperty("fileName", NullValueHandling = NullValueHandling.Ignore)]
        public string FileName { get; set; }

        [JsonProperty("flagInteraction", NullValueHandling = NullValueHandling.Ignore)]
        public FlagInteraction? FlagInteraction { get; set; }

        [JsonProperty("flags", NullValueHandling = NullValueHandling.Ignore)]
        public List<ModelFlag> Flags { get; set; }

        [JsonProperty("skybox", NullValueHandling = NullValueHandling.Ignore)]
        public string Skybox { get; set; }

        [JsonProperty("skyboxTint", NullValueHandling = NullValueHandling.Ignore)]
        public string SkyboxTint { get; set; }

        [JsonProperty("aspectRatio", NullValueHandling = NullValueHandling.Ignore)]
        public AspectRatio? AspectRatio { get; set; }

        [JsonProperty("autoStart", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AutoStart { get; set; }

        [JsonProperty("loop", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Loop { get; set; }

        [JsonProperty("videoEvents", NullValueHandling = NullValueHandling.Ignore)]
        public List<VideoEvent> VideoEvents { get; set; }

        [JsonProperty("cameraVerticalAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? CameraVerticalAngle { get; set; }

        [JsonProperty("rotationSpeed", NullValueHandling = NullValueHandling.Ignore)]
        public double? RotationSpeed { get; set; }
    }

    public partial class CameraAnimation
    {
        [JsonProperty("distance", NullValueHandling = NullValueHandling.Ignore)]
        public double? Distance { get; set; }

        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public double? Height { get; set; }

        [JsonProperty("lookAt", NullValueHandling = NullValueHandling.Ignore)]
        public ModelCameraTarget LookAt { get; set; }

        [JsonProperty("origin", NullValueHandling = NullValueHandling.Ignore)]
        public ModelCameraTarget Origin { get; set; }

        [JsonProperty("revolutionTime", NullValueHandling = NullValueHandling.Ignore)]
        public double? RevolutionTime { get; set; }
    }

    public partial class ModelCameraTarget
    {
        [JsonProperty("objectName", NullValueHandling = NullValueHandling.Ignore)]
        public string ObjectName { get; set; }

        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public Vector3 Offset { get; set; }
    }

    public partial class Vector3
    {
        [JsonProperty("X", NullValueHandling = NullValueHandling.Ignore)]
        public double? X { get; set; }

        [JsonProperty("Y", NullValueHandling = NullValueHandling.Ignore)]
        public double? Y { get; set; }

        [JsonProperty("Z", NullValueHandling = NullValueHandling.Ignore)]
        public double? Z { get; set; }
    }

    public partial class ModelFlag
    {
        [JsonProperty("activatedAction", NullValueHandling = NullValueHandling.Ignore)]
        public string ActivatedAction { get; set; }

        [JsonProperty("backgroundColor", NullValueHandling = NullValueHandling.Ignore)]
        public string BackgroundColor { get; set; }

        [JsonProperty("canSelect", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CanSelect { get; set; }

        [JsonProperty("foregroundColor", NullValueHandling = NullValueHandling.Ignore)]
        public string ForegroundColor { get; set; }

        [JsonProperty("location", NullValueHandling = NullValueHandling.Ignore)]
        public Vector3 Location { get; set; }

        [JsonProperty("selectedAction", NullValueHandling = NullValueHandling.Ignore)]
        public string SelectedAction { get; set; }

        [JsonProperty("stalkColor", NullValueHandling = NullValueHandling.Ignore)]
        public string StalkColor { get; set; }

        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }
    }

    public partial class Layout
    {
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public double? Height { get; set; }

        [JsonProperty("horizontalSpacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? HorizontalSpacing { get; set; }

        [JsonProperty("images", NullValueHandling = NullValueHandling.Ignore)]
        public List<GalleryImage> Images { get; set; }

        [JsonProperty("verticalSpacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? VerticalSpacing { get; set; }

        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public double? Width { get; set; }

        [JsonProperty("spacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? Spacing { get; set; }

        [JsonProperty("visibleImages", NullValueHandling = NullValueHandling.Ignore)]
        public double? VisibleImages { get; set; }
    }

    public partial class GalleryImage
    {
        [JsonProperty("activatedEvent", NullValueHandling = NullValueHandling.Ignore)]
        public string ActivatedEvent { get; set; }

        [JsonProperty("fileName", NullValueHandling = NullValueHandling.Ignore)]
        public string FileName { get; set; }

        [JsonProperty("selectedEvent", NullValueHandling = NullValueHandling.Ignore)]
        public string SelectedEvent { get; set; }
    }

    public partial class Vector2
    {
        [JsonProperty("X", NullValueHandling = NullValueHandling.Ignore)]
        public double? X { get; set; }

        [JsonProperty("Y", NullValueHandling = NullValueHandling.Ignore)]
        public double? Y { get; set; }
    }

    public partial class VideoEvent
    {
        [JsonProperty("eventName", NullValueHandling = NullValueHandling.Ignore)]
        public string EventName { get; set; }

        [JsonProperty("timestamp", NullValueHandling = NullValueHandling.Ignore)]
        public double? Timestamp { get; set; }
    }

    public partial class Sync
    {
        [JsonProperty("canvasDimensions", NullValueHandling = NullValueHandling.Ignore)]
        public CanvasDimensions CanvasDimensions { get; set; }

        [JsonProperty("elements", NullValueHandling = NullValueHandling.Ignore)]
        public List<Element> Elements { get; set; }

        [JsonProperty("relayAddress")]
        public string RelayAddress { get; set; }
    }

    public partial class CanvasDimensions
    {
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public long? Height { get; set; }

        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public long? Width { get; set; }
    }

    public partial class Element
    {
        [JsonProperty("hostname")]
        public string Hostname { get; set; }

        [JsonProperty("viewportTransform")]
        public string ViewportTransform { get; set; }
    }

    public enum RoundingMethod { Down, Up };

    public enum TypeEnum { Bool, Complex, Float, Integer, String, Void };

    public enum AspectRatio { FitInside, FitOutside, Stretch };

    public enum FlagInteraction { Point, Swipe };

    public enum LayoutType { Grid, List };

    public partial struct ComparisonValue
    {
        public bool? Bool;
        public double? Double;
        public string String;

        public static implicit operator ComparisonValue(bool Bool) => new ComparisonValue { Bool = Bool };
        public static implicit operator ComparisonValue(double Double) => new ComparisonValue { Double = Double };
        public static implicit operator ComparisonValue(string String) => new ComparisonValue { String = String };
    }

    public partial struct InM
    {
        public bool? Bool;
        public double? Double;

        public static implicit operator InM(bool Bool) => new InM { Bool = Bool };
        public static implicit operator InM(double Double) => new InM { Double = Double };
    }

    public partial struct OutM
    {
        public double? Double;
        public string String;

        public static implicit operator OutM(double Double) => new OutM { Double = Double };
        public static implicit operator OutM(string String) => new OutM { String = String };
    }

    public partial class PackageDescriptor
    {
        public static PackageDescriptor FromJson(string json) => JsonConvert.DeserializeObject<PackageDescriptor>(json, Naki3D.Common.Json.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this PackageDescriptor self) => JsonConvert.SerializeObject(self, Naki3D.Common.Json.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ComparisonValueConverter.Singleton,
                InMConverter.Singleton,
                OutMConverter.Singleton,
                RoundingMethodConverter.Singleton,
                TypeEnumConverter.Singleton,
                AspectRatioConverter.Singleton,
                FlagInteractionConverter.Singleton,
                LayoutTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ComparisonValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ComparisonValue) || t == typeof(ComparisonValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new ComparisonValue { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new ComparisonValue { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new ComparisonValue { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type ComparisonValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ComparisonValue)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type ComparisonValue");
        }

        public static readonly ComparisonValueConverter Singleton = new ComparisonValueConverter();
    }

    internal class InMConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(InM) || t == typeof(InM?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new InM { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new InM { Bool = boolValue };
            }
            throw new Exception("Cannot unmarshal type InM");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (InM)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            throw new Exception("Cannot marshal type InM");
        }

        public static readonly InMConverter Singleton = new InMConverter();
    }

    internal class OutMConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OutM) || t == typeof(OutM?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new OutM { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new OutM { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type OutM");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (OutM)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type OutM");
        }

        public static readonly OutMConverter Singleton = new OutMConverter();
    }

    internal class RoundingMethodConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RoundingMethod) || t == typeof(RoundingMethod?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "down":
                    return RoundingMethod.Down;
                case "up":
                    return RoundingMethod.Up;
            }
            throw new Exception("Cannot unmarshal type RoundingMethod");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (RoundingMethod)untypedValue;
            switch (value)
            {
                case RoundingMethod.Down:
                    serializer.Serialize(writer, "down");
                    return;
                case RoundingMethod.Up:
                    serializer.Serialize(writer, "up");
                    return;
            }
            throw new Exception("Cannot marshal type RoundingMethod");
        }

        public static readonly RoundingMethodConverter Singleton = new RoundingMethodConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bool":
                    return TypeEnum.Bool;
                case "complex":
                    return TypeEnum.Complex;
                case "float":
                    return TypeEnum.Float;
                case "integer":
                    return TypeEnum.Integer;
                case "string":
                    return TypeEnum.String;
                case "void":
                    return TypeEnum.Void;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.Bool:
                    serializer.Serialize(writer, "bool");
                    return;
                case TypeEnum.Complex:
                    serializer.Serialize(writer, "complex");
                    return;
                case TypeEnum.Float:
                    serializer.Serialize(writer, "float");
                    return;
                case TypeEnum.Integer:
                    serializer.Serialize(writer, "integer");
                    return;
                case TypeEnum.String:
                    serializer.Serialize(writer, "string");
                    return;
                case TypeEnum.Void:
                    serializer.Serialize(writer, "void");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }

    internal class AspectRatioConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AspectRatio) || t == typeof(AspectRatio?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "fitInside":
                    return AspectRatio.FitInside;
                case "fitOutside":
                    return AspectRatio.FitOutside;
                case "stretch":
                    return AspectRatio.Stretch;
            }
            throw new Exception("Cannot unmarshal type AspectRatio");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AspectRatio)untypedValue;
            switch (value)
            {
                case AspectRatio.FitInside:
                    serializer.Serialize(writer, "fitInside");
                    return;
                case AspectRatio.FitOutside:
                    serializer.Serialize(writer, "fitOutside");
                    return;
                case AspectRatio.Stretch:
                    serializer.Serialize(writer, "stretch");
                    return;
            }
            throw new Exception("Cannot marshal type AspectRatio");
        }

        public static readonly AspectRatioConverter Singleton = new AspectRatioConverter();
    }

    internal class FlagInteractionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FlagInteraction) || t == typeof(FlagInteraction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "point":
                    return FlagInteraction.Point;
                case "swipe":
                    return FlagInteraction.Swipe;
            }
            throw new Exception("Cannot unmarshal type FlagInteraction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FlagInteraction)untypedValue;
            switch (value)
            {
                case FlagInteraction.Point:
                    serializer.Serialize(writer, "point");
                    return;
                case FlagInteraction.Swipe:
                    serializer.Serialize(writer, "swipe");
                    return;
            }
            throw new Exception("Cannot marshal type FlagInteraction");
        }

        public static readonly FlagInteractionConverter Singleton = new FlagInteractionConverter();
    }

    internal class LayoutTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LayoutType) || t == typeof(LayoutType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "grid":
                    return LayoutType.Grid;
                case "list":
                    return LayoutType.List;
            }
            throw new Exception("Cannot unmarshal type LayoutType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LayoutType)untypedValue;
            switch (value)
            {
                case LayoutType.Grid:
                    serializer.Serialize(writer, "grid");
                    return;
                case LayoutType.List:
                    serializer.Serialize(writer, "list");
                    return;
            }
            throw new Exception("Cannot marshal type LayoutType");
        }

        public static readonly LayoutTypeConverter Singleton = new LayoutTypeConverter();
    }
}
